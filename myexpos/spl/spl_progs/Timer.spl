[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;

backup;

//Checking for the deadlocks

alias DEADLOCKED_PROC R3;

alias SEEN_PROC R4;

DEADLOCKED_PROC = 75*512;

SEEN_PROC = 75*512 + 16;

alias DeadLocked R5;

alias Seen R6;

DeadLocked = 75*512 + 32;

Seen = 0;
//print [DeadLocked];

alias Cur_Proc R7;

Cur_Proc = 0;

while(Cur_Proc < MAX_PROC_NUM) do

	if([PROCESS_TABLE + Cur_Proc*16 + 4] == WAIT_PROCESS) then

		alias j R8;

		j = 0;
		
		//checking whether the current process is already deadlocked or not

		while(j < MAX_PROC_NUM) do
		
			if([DEADLOCKED_PROC + j] == Cur_Proc)then
		
				break;
		
			endif;
		
			j = j + 1;
		
		endwhile;

            //print j;
		
		if(j == MAX_PROC_NUM) then
			
			alias Cur R9;

			Cur = Cur_Proc;

			//loop until we made sure it is not a dead lock process
			
                  Seen = 0;

			while(1 == 1) do
			
				j = 0;
			
				//if the current process is already seen in this loop it is deadlocked

				while(j < MAX_PROC_NUM)do
			
					if([SEEN_PROC + j] == Cur)then
			
						break;
			
					endif;
			
					j = j + 1;
			
				endwhile;
				
				//adding all the seen processes to deadlocked processes

				if(j != MAX_PROC_NUM) then
				
					//print "came";
				
					alias proc_in_loop R10;
				
					proc_in_loop = 0;
				
					while([SEEN_PROC + proc_in_loop] > 0) do
				
						[DEADLOCKED_PROC + [DeadLocked]] = [SEEN_PROC + proc_in_loop];
				
						print [DEADLOCKED_PROC + [DeadLocked]];
				
						[DeadLocked] = [DeadLocked] + 1;
				
						[SEEN_PROC + proc_in_loop] = -1;
				
						proc_in_loop = proc_in_loop + 1;
				
					endwhile;
				
					Seen = 0;
				
					break;
					
				else
				
					//If it not seen in the current loop
					
					j = 0;

					while(j < MAX_PROC_NUM) do
					
						if([DEADLOCKED_PROC + j] == Cur)then
					
							break;
					
						endif;
					
						j = j + 1;
					
					endwhile;
					
					if(j != MAX_PROC_NUM) then
					
						//print "came";
					
						alias proc_in_loop R15;
					
						proc_in_loop = 0;
					
						while([SEEN_PROC + proc_in_loop] > 0) do
					
							[DEADLOCKED_PROC + [DeadLocked]] = [SEEN_PROC + proc_in_loop];
					
							print [DEADLOCKED_PROC + [DeadLocked]];
					
							[SEEN_PROC + proc_in_loop] = -1;
					
							[DeadLocked] = [DeadLocked] + 1;
					
							proc_in_loop = proc_in_loop + 1;
					
						endwhile;
					
						Seen = 0;
					
						break;
					
					endif;
					
					//If not update seen table

                              //print Seen;
					
					[SEEN_PROC + Seen] = Cur;
					
					Seen = Seen + 1;
				
				endif;
				
				
				if([PROCESS_TABLE + Cur*16 + 4] != WAIT_PROCESS) then
				
					j = 0;
				
					while([SEEN_PROC + j] > 0) do
				
						[SEEN_PROC + j] = -1;
				
						j = j + 1;
				
					endwhile;
				
					Seen = 0;
				
					break;
				
				endif;
				
				Cur = [PROCESS_TABLE + Cur*16 + 5];

                        //print Cur;
						
			endwhile;
		
		endif;
		
	endif;
	
	Cur_Proc = Cur_Proc + 1;

endwhile;

//print [DeadLocked];

alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE + 1];

alias process_table_entry R1;
process_table_entry = PROCESS_TABLE + currentPID * 16;

[process_table_entry + 4] = READY;

alias counter R4;
counter = 0;
while(counter<MAX_PROC_NUM) do
     if([PROCESS_TABLE+(counter)*16+4]!=TERMINATED) then
           [PROCESS_TABLE+(counter)*16]=[PROCESS_TABLE+(counter)*16]+1;
     endif;
     counter=counter+1;
endwhile;



call MOD_5;

restore;
SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13];
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;
ireturn;
